# JS引用类型
数组，对象，函数
# typeof得到6种类型,可以区分值类型。
number,string,boolean,object,undefined,function
# 强制类型转换
总结可以有4种：
字符串：
==运算符：
if语句：判断为false的几种情况（NaN,0,null,undefined,false,''）
逻辑运算符：判断变量是true还是false，使用!!双感叹号
# 使用==还是===
obj.a==null的等效形式，也是jQuery推荐写法obj.a===null||obj.a===undefined，其余情况下可以用===
# JS内置函数-数据封装类对象：
Number，String，Boolean，Object,Array,Function.RegExp,Date,Error，9种;JSON,Math是内置对象。
# 原型
1.  所有的引用类型（数组，函数，对象）都有对象特性，即可自由扩展属性。除了null外
2.  所有的引用类型（对象，数组，函数）都有一个__proto__属性(隐式原型），属性值是一个普通对象
3.  所有的函数都有一个prototype属性（显式原型），属性值是一个普通的对象
4.  所有的引用类型（对象，数组，函数）的__proto__属性值，指向它的构造函数的prototype属性值，严格等于。
5.  {}的语法糖：new Object()；[]的语法糖：new Array();function fn(){}的语法糖：new Function()
6.  判断引用类型属于哪个构造函数的方法： 变量 instanceOf 构造函数 ；依据原型链逐级向上找
7.  for in循环在高级浏览器中会屏蔽来自原型上的属性；if(f.hasOwnPrototype(item){},只要对象自身上的属性
# 原型链
1.  对象.__proto__.__proto__：对象的隐式原型中，隐式原型也是一个对象，隐式原型的隐式原型。
2.  new 一个对象的过程：
    创建一个新对象；this会指向这个新对象；执行代码，会对this赋值；最后返回这个this;
3.  原型继承实例
   ```javascript
   //封装dom查询
   function Elem(id){
      this.elem=document.getElementById(id);
   }
   Elem.prototype.html=function(val){
      var elem=this.elem;
      if(val){
        elem.innerTML=val;
        return this;//链式操作
      }else{
        return elem.innerHTML;
      }
   }
   Elem.prototype.on=function(type,fn){
      var elem=this.elem;
      elem.addEventListener(type,fn);
   }
   var div1=new Elem('divId');
   console.log(div1.html('hello'));
   div1.html('<p>hello,word</p>');
   div1.on('click',function(){
      alert('clicked');
   })
   ```
4.  
5.  



