# JS引用类型
数组，对象，函数
# typeof得到6种类型,可以区分值类型。
number,string,boolean,object,undefined,function
# 强制类型转换
总结可以有4种：
字符串：
==运算符：
if语句：判断为false的几种情况（NaN,0,null,undefined,false,''）
逻辑运算符：判断变量是true还是false，使用!!双感叹号
# 使用==还是===
obj.a==null的等效形式，也是jQuery推荐写法obj.a===null||obj.a===undefined，其余情况下可以用===
# JS内置函数-数据封装类对象：
Number，String，Boolean，Object,Array,Function.RegExp,Date,Error，9种;JSON,Math是内置对象。
# 原型
1.  所有的引用类型（数组，函数，对象）都有对象特性，即可自由扩展属性。除了null外
2.  所有的引用类型（对象，数组，函数）都有一个__proto__属性(隐式原型），属性值是一个普通对象
3.  所有的函数都有一个prototype属性（显式原型），属性值是一个普通的对象
4.  所有的引用类型（对象，数组，函数）的__proto__属性值，指向它的构造函数的prototype属性值，严格等于。
5.  {}的语法糖：new Object()；[]的语法糖：new Array();function fn(){}的语法糖：new Function()
6.  判断引用类型属于哪个构造函数的方法： 变量 instanceOf 构造函数 ；依据原型链逐级向上找
7.  for in循环在高级浏览器中会屏蔽来自原型上的属性；if(f.hasOwnPrototype(item){},只要对象自身上的属性
# 原型链
1.  对象.__proto__.__proto__：对象的隐式原型中，隐式原型也是一个对象，隐式原型的隐式原型。
2.  new 一个对象的过程：
    创建一个新对象；this会指向这个新对象；执行代码，会对this赋值；最后返回这个this;
3.  原型继承实例
   ```javascript
   //封装dom查询
   function Elem(id){
      this.elem=document.getElementById(id);
   }
   Elem.prototype.html=function(val){
      var elem=this.elem;
      if(val){
        elem.innerTML=val;
        return this;//链式操作
      }else{
        return elem.innerHTML;
      }
   }
   Elem.prototype.on=function(type,fn){
      var elem=this.elem;
      elem.addEventListener(type,fn);
   }
   var div1=new Elem('divId');
   console.log(div1.html('hello'));
   div1.html('<p>hello,word</p>');
   div1.on('click',function(){
      alert('clicked');
   })
   //链式操作
   div1.html('').on('click',function(){});
   ```
4.  
# 作用域和闭包
1.  执行上下文：先执行，再定义，运行不报错，
    范围：一段script标签或者一个函数；
    全局（script标签）：变量定义和函数声明，就已经存在了
    函数（一个函数）：变量定义和函数声明，this,arguments 就已经存在了
2.  this是运行时确认的，定义时无法确认。
    作为构造函数执行：指向实例对象
    作为对象属性执行：指向对象自身
    作为普通函数执行：指向window对象
    call,apply,bind:改变this指向；fn.call(指向对象，参数列表），fn.apply(指向对象，参数列表数组），fn函数表达式.bind(指向对象，参数列表）；
3.  没有块级作用域，只有函数和全局作用域。
    当前作用域没有定义的变量是自由变量，查找变量的定义会去父级作用域找（定义时的父级作用域，不是运行时的作用域）
    作用域链即是自由变量的查找
5.  闭包的使用场景：函数作为返回值，函数作为参数传递
6.  闭包的应用，封装变量，收敛权限
# 异步和单线程
1.  同步会阻塞程序执行，比如alert函数，异步不会阻塞执行。
2.  异步场景：setTimeout,setIntervar,网络请求，动态img加载，事件绑定
3.  单线程执行导致JS需要异步队列来执行异步函数
# JS Web API
1.  property:一个对JS对象的属性的修改，如className;attribute:一个对HTML标签属性的修改，如getAttribute,setAttribute;
2.  DOM结构操作
    新增：document.createElement()和dom.appendChild();dom1.appendChild(已有的节点）
    获取父元素：dom.parentElement
    获取子元素：dom.childNodes获得子元素数组
    删除节点：dom.removeChild(子元素）；
    nodeType是1，表示标签类型；3，表示文本类型
    nodeName是#text是空白标签，nodeName是大写P，代表标签类型
    DOM是树形结构
3.  BOM操作
    检查浏览器类型：navigator.userAgent;
    屏幕信息：screen.width,screen.height;
    url各部分：location.href全路径,protocol协议,pathname路径,search查询字符串,hash哈希,host域名
    history:history.back后退，forward前进
4.  通用事件监听函数
    ```javascript
    function bindEvent(elem,type,selector,fn){
        if(fn==null){
            fn=selector
            selector=null
        }
          elem.addEventListener(type,function(e){
            var target;
            if(selector){
                target=e.target;
                if(target.matches(selector){
                    fn.call(target,e)
                }
            }else{
                fn(e)
            }
          });
    }
    bindEvent(a,'click',function(e){
       e.preventDefault();
       alert('clicked');
    })
    ```
5. 事件冒泡流程
    e.stopPropatation()阻止冒泡
# Ajax
  ```javascript
  var xhr=new XMLHttpRequest();
  xhr.open('GET','/api',false);
  xhr.onreadystatechange=function(){
    //异步
    // 状态码
    //0 未初始化，没调用send()
    //1 调用send()
    //2 接收到全部响应内容
    //3 正在解析响应内容
    //4 解析完成
   
    if(xhr.readyState==4){
        // http状态码
        if(xhr.status==200){
            alert(xhr.responseText);
        }
    }
  }
  xhr.send(null);
  ```
2.  浏览器的同源策略，不允许ajx访问其他域下的接口；协议，域名，端口，有一个不同，跨域就会出现
3.  三个可以跨域加载资源的标签：img打点统计,script可以用于JSONP,link使用CDN资源
4.  JSONP原理
    ```javascript
     <script>
        window.callback=function(data){
            console.log(data);//这里处理跨域得到的信息
        }
     </script>
     <!--   以下的跨域接口将返回：callback({x:100,y:200}  JS片段  -->
     <script src="http:///wwww.com></script>
    ```
5.  服务器设置http header解决跨域
# 存储
1.  cookie,本是客户端和服务器的通信，存储是借用的功能。document.cookie获取字符串；存储太小，4kb,所有http请求都需要带着
2.  locationStorage，最大5M容量；localStorage.setItem(key,value),localStorage.getItem(key);http请求不用携带
3.  sessionStorage,会话结束被清理。
4.  IOS safari隐藏模式下，localStorage.getItem会出错，建议统一使用try-catch封装
# 开发环境
1.  Git
    git add . 加入本地版本库
    git checkout xxx 切换分支
    git commit -m '' 提交
    git push origin master 推送
    git pull origin master 拉取
    git branch 当前分支
    git checkout -b 新建分支并切换
    git merge xxx 合并分支
    git reset HEAD 文件路径  丢弃修改
2.  JS模块化
    不使用模块化：全局变量污染
    -  AMD规范
        -  require.js
        -  全局define，require函数
        -  依赖的JS会自动、异步加载
    -  commonJS规范
        -  nodeJS模块化规范
        -  不会异步加载，而是同步一次性加载出来
        -  module.exports()
        -  require()
5.  打包工具
    ```javascript
        var path=require('path');
        var webpack=require('webpack');
        module.exports={
            context:path.resolve(__dirname,'./src')，
            entry:{
                app:'./app.js'
            }，
            output:{
                path:path.resolve(__dirname,'./dist');
                filename:'bundle.js'
            },
            plugins:[
                new webpack.optimize.UglifyJsPlugin();//压缩JS
            ]
        }
    ```
7.  上线回滚
    -  上线
         -  测试通过的代码提交master分支
         -  将服务器上现有的代码打包备份并记录版本号，以备回滚
         -  提交master分支的新代码到线上服务器，并生成新版本号
    -  回滚
         -  将服务器上有问题的代码打包本分，并记录版本号
         -  将上一个版本号的代码覆盖到线上服务器，并生成新的版本号
8.  linux操作
    ```shell
        mkdir 文件名
        ls,ll查看目录
        pwd当前目录
        rm -rf 删除的文件名
        mv 移动的文件路径 新路径
        cat 文件路径
        head -n 第几行 文件路径；看文件头部
        tail -n 倒数第几行 文件路径；看文件末尾
        grep '想搜索的字符串'  文件路径；搜索指定文件内容
        vim 新文件名 
        i 插入模式 esc键退出插入模式  :w保存文件 :q退出
    ```
10.  



























    





