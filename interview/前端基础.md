# JS引用类型
数组，对象，函数
# typeof得到6种类型,可以区分值类型。
number,string,boolean,object,undefined,function
# 强制类型转换
总结可以有4种：
字符串：
==运算符：
if语句：判断为false的几种情况（NaN,0,null,undefined,false,''）
逻辑运算符：判断变量是true还是false，使用!!双感叹号
# 使用==还是===
obj.a==null的等效形式，也是jQuery推荐写法obj.a===null||obj.a===undefined，其余情况下可以用===
# JS内置函数-数据封装类对象：
Number，String，Boolean，Object,Array,Function.RegExp,Date,Error，9种;JSON,Math是内置对象。
# 原型
1.  所有的引用类型（数组，函数，对象）都有对象特性，即可自由扩展属性。除了null外
2.  所有的引用类型（对象，数组，函数）都有一个__proto__属性(隐式原型），属性值是一个普通对象
3.  所有的函数都有一个prototype属性（显式原型），属性值是一个普通的对象
4.  所有的引用类型（对象，数组，函数）的__proto__属性值，指向它的构造函数的prototype属性值，严格等于。
5.  {}的语法糖：new Object()；[]的语法糖：new Array();function fn(){}的语法糖：new Function()
6.  判断引用类型属于哪个构造函数的方法： 变量 instanceOf 构造函数 ；依据原型链逐级向上找
7.  for in循环在高级浏览器中会屏蔽来自原型上的属性；if(f.hasOwnPrototype(item){},只要对象自身上的属性
# 原型链
1.  对象.__proto__.__proto__：对象的隐式原型中，隐式原型也是一个对象，隐式原型的隐式原型。
2.  new 一个对象的过程：
    创建一个新对象；this会指向这个新对象；执行代码，会对this赋值；最后返回这个this;
3.  原型继承实例
   ```javascript
   //封装dom查询
   function Elem(id){
      this.elem=document.getElementById(id);
   }
   Elem.prototype.html=function(val){
      var elem=this.elem;
      if(val){
        elem.innerTML=val;
        return this;//链式操作
      }else{
        return elem.innerHTML;
      }
   }
   Elem.prototype.on=function(type,fn){
      var elem=this.elem;
      elem.addEventListener(type,fn);
   }
   var div1=new Elem('divId');
   console.log(div1.html('hello'));
   div1.html('<p>hello,word</p>');
   div1.on('click',function(){
      alert('clicked');
   })
   //链式操作
   div1.html('').on('click',function(){});
   ```
4.  
# 作用域和闭包
1.  执行上下文：先执行，再定义，运行不报错，
    范围：一段script标签或者一个函数；
    全局（script标签）：变量定义和函数声明，就已经存在了
    函数（一个函数）：变量定义和函数声明，this,arguments 就已经存在了
2.  this是运行时确认的，定义时无法确认。
    作为构造函数执行：指向实例对象
    作为对象属性执行：指向对象自身
    作为普通函数执行：指向window对象
    call,apply,bind:改变this指向；fn.call(指向对象，参数列表），fn.apply(指向对象，参数列表数组），fn函数表达式.bind(指向对象，参数列表）；
3.  没有块级作用域，只有函数和全局作用域。
    当前作用域没有定义的变量是自由变量，查找变量的定义会去父级作用域找（定义时的父级作用域，不是运行时的作用域）
    作用域链即是自由变量的查找
5.  闭包的使用场景：函数作为返回值，函数作为参数传递
6.  闭包的应用，封装变量，收敛权限
# 异步和单线程
1.  同步会阻塞程序执行，比如alert函数，异步不会阻塞执行。
2.  异步场景：setTimeout,setIntervar,网络请求，动态img加载，事件绑定
3.  单线程执行导致JS需要异步队列来执行异步函数
# JS Web API
1.  property:一个对JS对象的属性的修改，如className;attribute:一个对HTML标签属性的修改，如getAttribute,setAttribute;
2.  DOM结构操作
    新增：document.createElement()和dom.appendChild();dom1.appendChild(已有的节点）
    获取父元素：dom.parentElement
    获取子元素：dom.childNodes获得子元素数组
    删除节点：dom.removeChild(子元素）；
    nodeType是1，表示标签类型；3，表示文本类型
    nodeName是#text是空白标签，nodeName是大写P，代表标签类型
    DOM是树形结构
3.  BOM操作
    检查浏览器类型：navigator.userAgent;
    屏幕信息：screen.width,screen.height;
    url各部分：location.href全路径,protocol协议,pathname路径,search查询字符串,hash哈希,host域名
    history:history.back后退，forward前进
4.  通用事件监听函数
    ```javascript
    function bindEvent(elem,type,selector,fn){
        if(fn==null){
            fn=selector
            selector=null
        }
          elem.addEventListener(type,function(e){
            var target;
            if(selector){
                target=e.target;
                if(target.matches(selector){
                    fn.call(target,e)
                }
            }else{
                fn(e)
            }
          });
    }
    bindEvent(a,'click',function(e){
       e.preventDefault();
       alert('clicked');
    })
    ```
5. 事件冒泡流程
    e.stopPropatation()阻止冒泡
# Ajax
  ```javascript
  var xhr=new XMLHttpRequest();
  xhr.open('GET','/api',false);
  xhr.onreadystatechange=function(){
    //异步
    // 状态码
    //0 未初始化，没调用send()
    //1 调用send()
    //2 接收到全部响应内容
    //3 正在解析响应内容
    //4 解析完成
   
    if(xhr.readyState==4){
        // http状态码
        if(xhr.status==200){
            alert(xhr.responseText);
        }
    }
  }
  xhr.send(null);
  ```
2.  

























    




